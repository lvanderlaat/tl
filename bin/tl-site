#!/usr/bin/env python


"""
Determine site amplification correction factors.
Based on Eibl et al. (2017)
"""


# Python Standard Library
import os

# Other dependencies
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import tl

from scipy.optimize import curve_fit


__author__ = 'Leonardo van der Laat'
__email__  = 'laat@umich.edu'


def attenuation(x, Q, A0, alpha, beta, f):
    B = np.pi*f/Q/beta
    return A0*np.exp(-B*x)/x**alpha


def main():
    # Parse arguments
    args = tl.utils.parse_args()

    # Parse configuration YAML file
    c = tl.config.read(args.configfile)

    # Output folder directory
    folderpath = tl.utils.create_folder(c.io.output_dir, f'SITE', c.io.overwrite)

    # Logger
    logger = tl.utils.get_logger()

    # Channels
    channels = pd.read_csv(c.amplitude.channels_csv, comment='/')
    channels = channels[channels.channel.str[-1] == 'Z']
    channels.reset_index(inplace=True)

    # features metadata
    meta = tl.features.to_dataframe(channels, c.amplitude.bands)

    # Read catalog
    df = pd.read_csv(os.path.join(c.engineer.amp_folder, 'data.csv'))
    df = tl.catalog.filter(
        df,
        magnitude_min=c.dataset.magnitude_min,
        magnitude_max=c.dataset.magnitude_max,
        n_events=c.dataset.n_events
    )

    # Earthqueke locations
    x = df.x.values
    y = df.y.values
    z = df.z.values

    X = np.full((x.shape[0], len(channels)), np.nan)
    for i, row in channels.iterrows():
        X[:, i] = np.sqrt((x-row.x)**2 + (y-row.y)**2 + (z-row.z)**2)

    meta['cf'] = np.nan
    for band in c.amplitude.bands:
        _meta = meta[(meta.freqmin == band[0]) & (meta.freqmax == band[1])]
        _meta.reset_index(inplace=True)

        Y = df[_meta.key].values
        Y /= Y.max(axis=1, keepdims=True)

        _df = pd.DataFrame(dict(x=X.flatten(), y=Y.flatten()))
        _df.sort_values(by='x', inplace=True)
        _df.index = _df.x

        # Reduce
        n = len(_df)
        _df = _df[(_df.x > xmin) & (_df.x < xmax)]
        _df = _df.groupby(_df.index//reduction_factor).median()

        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.set_title(f'{band[0]}-{band[1]} Hz')
        ax.set_xlabel('Distance [m]')
        ax.set_ylabel('Normalized amplitude')
        ax.scatter(X.flatten(), Y.flatten(), s=1e-5)
        ax.scatter(_df.x, _df.y, s=1e-2, c='r')

        for alpha in [1, 0.5]:
            popt, pcov = curve_fit(
                attenuation, _df.x, _df.y,
                bounds=(
                    [0,        1, alpha-1e-3, 1500, band[0]],
                    [200,   np.inf, alpha+1e-3, 3500, band[1]]
                ),
            )
            _x = np.arange(X.min(), X.max())
            _y = attenuation(_x, *popt)

            label = (
                f'Q = {popt[0]:.0f}, '
                rf'$A_0$ = {popt[1]:.0f}, '
                rf'$\alpha$ = {popt[2]:.1f}, '
                rf'$\beta$  = {popt[3]:.0f} m/s'
            )
            ax.plot(_x, _y, label=label)

        plt.legend()
        plt.ylim(0, 1)
        plt.xlim(0, 14e3)
        fig.savefig(os.path.join(folderpath, f'{band[0]}-{band[1]}.png'))

        for i, row in _meta.iterrows():
            y_true = Y[:, i]
            y_pred = attenuation(X[:, i], *popt)

            meta.loc[
                (meta.station == row.station) & (meta.channel == row.channel) &
                (meta.freqmin == row.freqmin) & (meta.freqmax == row.freqmax),
                'cf'
            ] = np.median(y_true/y_pred)

    meta.to_csv(os.path.join(folderpath, 'meta.csv'), index=True)
    return


if __name__ == '__main__':
    reduction_factor = 1
    xmin, xmax = 600, 13e3
    main()
