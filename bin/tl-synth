#!/usr/bin/env python


"""
Train a model with real target locations, but synthetic amplitudes. Predict
misfit distribution.
"""


# Python Standard Library
import datetime
import os

# Other dependencies
import numpy as np
import pandas as pd

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Local files
import tl


__author__ = 'Leonardo van der Laat'
__email__  = 'laat@umich.edu'


def main():
    # Parse configuration file
    args = tl.utils.parse_args()
    c = tl.config.read(args.configfile)

    # Create output folder
    folderpath = tl.utils.create_folder(c.io.output_dir, 'SYNTH', c.io.overwrite)

    # Logger
    logger = tl.utils.get_logger()

    # Load metadata
    channels = pd.read_csv(c.features.channels_csv, comment='/')
    # features metadata
    meta = tl.features.to_dataframe(channels, c.features.bands)
    # Only one channel per station
    meta = meta.drop_duplicates(subset='station')

    # Load data
    df = tl.catalog.read(c.dataset.catalog)
    # Filter data
    df = tl.catalog.filter(
        df,
        magnitude_min=c.dataset.magnitude_min,
        magnitude_max=c.dataset.magnitude_max,
        n_events=c.dataset.n_events
    )

    # Generate features
    X, y = tl.synth.get_data(
        df, meta, c.synth.f, c.synth.Q, c.synth.beta, c.synth.alpha,
        source_amplitude=True
    )

    # TRAIN-TEST SPLIT
    eventids = df.eventid.values

    # Split training and testing data sets
    X_train, X_test, y_train, y_test, evid_train, evid_test = train_test_split(
        X, y, eventids, test_size=c.train.test_size,
        random_state=c.train.random_state
    )

    logger.info(
        f'n={X.shape[0]}, n(train)={X_train.shape[0]}, n(test)={X_test.shape[0]}'
    )

    model = LinearRegression()

    # Normalize
    scaler = StandardScaler()
    scaler.fit(X_train)
    X_train = scaler.transform(X_train)
    X_test  = scaler.transform(X_test)

    # Fit the model
    model.fit(X_train, y_train)

    # Predict test set
    y_pred = model.predict(X_test)

    # Scores
    misfits, interval, stdev = tl.train.get_scores(y_test, y_pred)
    logger.info(f'Test error: {int(misfits.mean())} m')
    logger.info(f'Standard deviation (xyz): {stdev.astype(int)} m')
    logger.info(f'Prediction interval (xyz): {interval.astype(int)} m')

    # Test Output Data
    df_true, df_pred = tl.train.results_to_df(y_test, y_pred, misfits, evid_test)

    # Plots
    fig = tl.plot.misfits_histograms(df_true, df_pred)
    fig.savefig(os.path.join(folderpath, 'misfits_histograms.pdf'))

    fig = tl.plot.locs_test_sample(df_true, df_pred, meta)
    fig.savefig(os.path.join(folderpath, 'test_locs_sample.pdf'), dpi=300)

    fig = tl.plot.locs_true_pred(df_true, df_pred, meta, s=10)
    fig.savefig(os.path.join(folderpath, 'test_locs_all.pdf'), dpi=300)

    # TOTAL
    # Normalize
    model = LinearRegression()
    scaler = StandardScaler()
    X = scaler.fit_transform(X)
    model.fit(X, y)
    y_pred = model.predict(X)

    # Error
    misfits, interval, stdev = tl.train.get_scores(y, y_pred)
    logger.info(f'Total error: {int(misfits.mean())} m')
    logger.info(f'Standard deviation (xyz): {stdev.astype(int)} m')
    logger.info(f'Prediction interval (xyz): {interval.astype(int)} m')

    # Save the model and configuration
    tl.utils.write_conf(c, folderpath)
    tl.utils.write_model(model, folderpath)

    # Predict grid
    xmin, ymin = tl.projection.geographic_to_cartesian(
        c.synth.lonmin, c.synth.latmin, epsg=c.projection.epsg
    )
    xmax, ymax = tl.projection.geographic_to_cartesian(
        c.synth.lonmax, c.synth.latmax, epsg=c.projection.epsg
    )

    # Create grids
    # Map view
    xh = np.arange(xmin, xmax + c.synth.step, c.synth.step)
    yh = np.arange(ymin, ymax + c.synth.step, c.synth.step)

    xx, yy = np.meshgrid(xh, yh)

    z = np.ones(xx.flatten().shape)*c.synth.z_plot

    dfh = pd.DataFrame(dict(x=xx.flatten(), y=yy.flatten(), z=z))

    tl.synth.get_misfit(
        dfh, meta, c.synth.f, c.synth.Q, c.synth.beta, c.synth.alpha, model,
        scaler
    )

    # Profile view
    zv = np.arange(c.synth.zmax, c.synth.zmin-c.synth.step, -c.synth.step)

    xx, zz = np.meshgrid(xh, zv)
    y_plot = (meta.y.min() + meta.y.max())/2
    y = np.ones(xx.flatten().shape)*y_plot

    dfv = pd.DataFrame(dict(x=xx.flatten(), y=y, z=zz.flatten()))
    tl.synth.get_misfit(dfv, meta, c.synth.f, c.synth.Q, c.synth.beta, c.synth.alpha,
               model, scaler)

    fig = tl.plot.synth_misfit(
        dfh, dfv, meta, y_plot, c.synth.z_plot, xh, yh, xh, zv, c.synth.step
    )
    fig.savefig(os.path.join(folderpath, 'misfit_distribution.pdf'), dpi=300)

    return


if __name__ == '__main__':
    main()
